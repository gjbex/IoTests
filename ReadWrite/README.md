# ReadWrite

Test application to experiment with read and write operation using various
buffer sizes for text, binary, and HDF5 output.

## What is it?
1. `build.sh`: script that will build the `writer` and `reader`
    executables.  It works out of the box on thinking and vanilla
    Linux, but may require setting paths, depending on how HDF5 was
    installed.
1. Various PBS scripts to run benchmarks
1. `src`: source code directory.

## Requirements
1. A C compiler, e.g., GNU gcc
1. HDF5 library has to be avialable (version 1.8.x).

## Building
Simply run the biuld script:
```bash
$ ./biuld.sh
```
If necessary, review the HDF5 installation path.

## Usage description
`writer` will create a new file containing `size` number of double
precision floating point numbers. It takes a buffer size expressed in
bytes, a file name, and a mode.

The mode can be:
1. `text`: create ASCII, i.e., human-readable output,
1. `binary`: create binary output, which may not be portable,
1. `hdf5`: create output in HDF5 format, the data will reside in a data
    set called `values`.

`reader` will read an existing file, and perform a trivial computation on
the data (result printed to standard error for verification, and to ensure
that optimizing compilers do not outsmart us).  A buffer size for reading
can be specified, as well as a file name and a mode.  The modes are of
course identical to that of `writer`.

## Examples
```bash
$ ./writer  -file data.bin  -mode binary  -buffer 0  -size $(( 1024**3 ))
```
This would write a file `data.bin` containing `2**30` double precision
floating point numbers, hence the resulting file size would be 8 Gb.  Since
the buffer size is 0, no buffering is used.

```bash
$ ./writer  -file data.h5  -mode hdf5  -buffer $(( 1024**2 ))  \
            -size $(( 1024**3 ))
```
This would produce an HDF5 file with the same `2**32` number as the first
example, but using a 1 Mb buffer.

```bash
$ ./reader  -file data.bin  -mode binary  -buffer 4096
```
This would read the file generated by the first `writer` example, using
the specified buffer size.  Note that the latter need by no means be
identical to that used to write the file.

## Discussion
Important notes:
1. Results may vary considerably over time when these tests are run
    on a shared file system.
1. If a read test is performed on a file that has just been written, file
    system caches my skew the results of the read by as much as an order
    of magnitude, so do not get unduly optimistic.
1. These application are implemented in C, somewhat different results might
    be obtained for implementations i other programming languages (Fortran
    and Python would be interesting to compare with)

In general, text I/O is much slower than binary or HDF5.

Although pure
binary I/O is some 10 % faster dan HDF5, this could be outweighed by the
latter's portability and extra functionality.

For binary I/O, buffering is benificial.  Buffer sizes should be of the
same order of that of the file system's block size.

Buffering for HDF5 can improve performance by approximately 10 % for large
buffer sizes (1 Mb), but it complicates the development since one has to
access memory and file data using hyperslabs.
